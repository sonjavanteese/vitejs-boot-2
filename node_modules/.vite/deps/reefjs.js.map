{
  "version": 3,
  "sources": ["../../reefjs/src/components/utilities.js", "../../reefjs/src/components/store.js", "../../reefjs/src/components/setter.js", "../../reefjs/src/components/render.js", "../../reefjs/src/components/component.js"],
  "sourcesContent": ["/**\n * Emit a custom event\n * @param  {String} type   The event type\n * @param  {*}      detail Any details to pass along with the event\n * @param  {Node}   elem   The element to emit the event on\n */\nfunction emit (type, detail, elem = document) {\n\n\t// Create a new event\n\tlet event = new CustomEvent(`reef:${type}`, {\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tdetail: detail\n\t});\n\n\t// Dispatch the event\n\treturn elem.dispatchEvent(event);\n\n}\n\n/**\n * Get the element from the UI\n * @param  {String|Node} elem The element or selector string\n * @return {Node}             The element\n */\nfunction getElem (elem) {\n\treturn typeof elem === 'string' ? document.querySelector(elem) : elem;\n}\n\n/**\n * Get an object's type\n * @param  {*}      obj The object\n * @return {String}     The type\n */\nfunction getType (obj) {\n\treturn Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n}\n\n/**\n * Create an immutable clone of data\n * @param  {*} obj The data object to copy\n * @return {*}     The clone of the array or object\n */\nfunction copy (obj) {\n\n\t/**\n\t * Create an immutable copy of an object\n\t * @return {Object}\n\t */\n\tfunction cloneObj () {\n\t\tlet clone = {};\n\t\tfor (let key in obj) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\tclone[key] = copy(obj[key]);\n\t\t\t}\n\t\t}\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Create an immutable copy of an array\n\t * @return {Array}\n\t */\n\tfunction cloneArr () {\n\t\treturn obj.map(function (item) {\n\t\t\treturn copy(item);\n\t\t});\n\t}\n\n\t// Get object type\n\tlet type = getType(obj);\n\n\t// Return a clone based on the object type\n\tif (type === 'object') return cloneObj();\n\tif (type === 'array') return cloneArr();\n\treturn obj;\n\n}\n\n\nexport {emit, getElem, getType, copy};", "import {emit, getType} from './utilities.js';\n\n\n/**\n * Create a Proxy handler object\n * @param  {String} name The custom event namespace\n * @param  {Object} data The data object\n * @return {Object}      The handler object\n */\nfunction handler (name, data) {\n\tlet type = 'store' + (name ? `-${name}` : '');\n\treturn {\n\t\tget (obj, prop) {\n\t\t\tif (prop === '_isProxy') return true;\n\t\t\tif (['object', 'array'].includes(getType(obj[prop])) && !obj[prop]._isProxy) {\n\t\t\t\tobj[prop] = new Proxy(obj[prop], handler(name, data));\n\t\t\t}\n\t\t\treturn obj[prop];\n\t\t},\n\t\tset (obj, prop, value) {\n\t\t\tif (obj[prop] === value) return true;\n\t\t\tobj[prop] = value;\n\t\t\temit(type, data);\n\t\t\treturn true;\n\t\t},\n\t\tdeleteProperty (obj, prop) {\n\t\t\tdelete obj[prop];\n\t\t\temit(type, data);\n\t\t\treturn true;\n\t\t}\n\t};\n}\n\n/**\n * Create a new store\n * @param  {Object} data The data object\n * @param  {String} name The custom event namespace\n * @return {Proxy}       The reactive proxy\n */\nfunction store (data = {}, name = '') {\n\tdata = ['array', 'object'].includes(getType(data)) ? data : {value: data};\n\treturn new Proxy(data, handler(name, data));\n}\n\n\nexport default store;", "import {emit, copy} from './utilities.js';\n\n\n/**\n * Setter Class\n */\nclass Setter {\n\n\t/**\n\t * The constructor object\n\t * @param  {Node|String} elem     The element or selector to render the template into\n\t * @param  {Function}    template The template function to run when the data updates\n\t * @param  {Object}      options  Additional options\n\t */\n\tconstructor (data, setters, name = '') {\n\n\t\t// Get store type\n\t\tlet type = 'store' + (name ? `-${name}` : '');\n\n\t\t// Create data property setter/getter\n\t\tObject.defineProperties(this, {\n\t\t\tdata: {\n\t\t\t\tget () {\n\t\t\t\t\treturn copy(data);\n\t\t\t\t},\n\t\t\t\tset () {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Add setter functions\n\t\tfor (let fn in setters) {\n\t\t\tif (typeof setters[fn] !== 'function') continue;\n\t\t\tthis[fn] = function (...args) {\n\t\t\t\tsetters[fn](data, ...args);\n\t\t\t\temit(type, data);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n/**\n * Create a new store\n * @param  {Object} data The data object\n * @param  {String} name The custom event namespace\n * @return {Proxy}       The reactive proxy\n */\nfunction setter (data = {}, setters = {}, name = '') {\n\treturn new Setter(data, setters, name);\n}\n\n\nexport default setter;", "import {emit, getElem} from './utilities.js';\n\n\n// Form fields and attributes that can be modified by users\n// They also have implicit values that make it hard to know if they were changed by the user or developer\nlet formFields = ['input', 'option', 'textarea'];\nlet formAtts = ['value', 'checked', 'selected'];\nlet formAttsNoVal = ['checked', 'selected'];\n\n/**\n * Convert a template string into HTML DOM nodes\n * @param  {String} str The template string\n * @return {Node}       The template HTML\n */\nfunction stringToHTML (str) {\n\n    // Create document\n    let parser = new DOMParser();\n    let doc = parser.parseFromString(str, 'text/html');\n\n    // If there are items in the head, move them to the body\n    if (doc.head && doc.head.childNodes.length) {\n        Array.from(doc.head.childNodes).reverse().forEach(function (node) {\n            doc.body.insertBefore(node, doc.body.firstChild);\n        });\n    }\n\n    return doc.body || document.createElement('body');\n\n}\n\n/**\n * Check if an attribute string has a stringified falsy value\n * @param  {String}  str The string\n * @return {Boolean}     If true, value is falsy (yea, I know, that's a little confusing)\n */\nfunction isFalsy (str) {\n\treturn ['false', 'null', 'undefined', '0', '-0', 'NaN', '0n', '-0n'].includes(str);\n}\n\n/**\n * Check if attribute should be skipped (sanitize properties)\n * @param  {String}  name   The attribute name\n * @param  {String}  value  The attribute value\n * @param  {Boolean} events If true, inline events are allowed\n * @return {Boolean}        If true, skip the attribute\n */\nfunction skipAttribute (name, value, events) {\n\tlet val = value.replace(/\\s+/g, '').toLowerCase();\n\tif (['src', 'href', 'xlink:href'].includes(name)) {\n\t\tif (val.includes('javascript:') || val.includes('data:text/html')) return true;\n\t}\n\tif (!events && name.startsWith('on')) return true;\n}\n\n/**\n * Add an attribute to an element\n * @param {Node}   elem The element\n * @param {String} att  The attribute\n * @param {String} val  The value\n * @param  {Boolean} events If true, inline events are allowed\n */\nfunction addAttribute (elem, att, val, events) {\n\n\t// Sanitize dangerous attributes\n\tif (skipAttribute(att, val, events)) return;\n\n\t// If it's a form attribute, set the property directly\n\tif (formAtts.includes(att)) {\n\t\telem[att] = att === 'value' ? val : ' ';\n\t}\n\n\t// Update the attribute\n\telem.setAttribute(att, val);\n\n\n}\n\n/**\n * Remove an attribute from an element\n * @param {Node}   elem The element\n * @param {String} att  The attribute\n */\nfunction removeAttribute (elem, att) {\n\n\t// If it's a form attribute, remove the property directly\n\tif (formAtts.includes(att)) {\n\t\telem[att] = '';\n\t}\n\n\t// Remove the attribute\n\telem.removeAttribute(att);\n\n}\n\n/**\n * Compare the existing node attributes to the template node attributes and make updates\n * @param  {Node}    template The new template\n * @param  {Node}    existing The existing DOM node\n * @param  {Boolean} events   If true, inline events allowed\n */\nfunction diffAttributes (template, existing, events) {\n\n\t// If the node is not an element, bail\n\tif (template.nodeType !== 1) return;\n\n\t// Get attributes for the template and existing DOM\n\tlet templateAtts = template.attributes;\n\tlet existingAtts = existing.attributes;\n\n\t// Add and update attributes from the template into the DOM\n\tfor (let {name, value} of templateAtts) {\n\n\t\t// Skip [#*] attributes\n\t\tif (name.startsWith('#')) continue;\n\n\t\t// Skip user-editable form field attributes\n\t\tif (formAtts.includes(name) && formFields.includes(template.tagName.toLowerCase())) continue;\n\n\t\t// Convert [@*] names to their real attribute name\n\t\tlet attName = name.startsWith('@') ? name.slice(1) : name;\n\n\t\t// If its a no-value property and it's falsy remove it\n\t\tif (formAttsNoVal.includes(attName) && isFalsy(value)) {\n\t\t\tremoveAttribute(existing, attName);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Otherwise, add the attribute\n\t\taddAttribute(existing, attName, value, events);\n\n\t}\n\n\t// Remove attributes from the DOM that shouldn't be there\n\tfor (let {name, value} of existingAtts) {\n\n\t\t// If the attribute exists in the template, skip it\n\t\tif (templateAtts[name]) continue;\n\n\t\t// Skip user-editable form field attributes\n\t\tif (formAtts.includes(name) && formFields.includes(existing.tagName.toLowerCase())) continue;\n\n\t\t// Otherwise, remove it\n\t\tremoveAttribute(existing, name);\n\n\t}\n\n}\n\n/**\n * Add default attributes to a newly created element\n * @param  {Node} elem The element\n */\nfunction addDefaultAtts (elem, events) {\n\n\t// Only run on elements\n\tif (elem.nodeType !== 1) return;\n\n\t// Remove [@*] and [#*] attributes and replace them with the plain attributes\n\t// Remove unsafe HTML attributes\n\tfor (let {name, value} of elem.attributes) {\n\n\t\t// If the attribute should be skipped, remove it\n\t\tif (skipAttribute(name, value, events)) {\n\t\t\tremoveAttribute(elem, name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If the attribute isn't a [@*] or [#*], skip it\n\t\tif (!name.startsWith('@') && !name.startsWith('#')) continue;\n\n\t\t// Get the plain attribute name\n\t\tlet attName = name.slice(1);\n\n\t\t// Remove the [@*] or [#*] attribute\n\t\tremoveAttribute(elem, name);\n\n\t\t// If it's a no-value attribute and its falsy, skip it\n\t\tif (formAttsNoVal.includes(attName) && isFalsy(value)) continue;\n\n\t\t// Add the plain attribute\n\t\taddAttribute(elem, attName, value, events);\n\n\t}\n\n\t// If there are child elems, recursively add defaults to them\n\tif (elem.childNodes) {\n\t\tfor (let node of elem.childNodes) {\n\t\t\taddDefaultAtts(node, events);\n\t\t}\n\t}\n\n}\n\n/**\n * Get the content from a node\n * @param  {Node}   node The node\n * @return {String}      The content\n */\nfunction getNodeContent (node) {\n\treturn node.childNodes && node.childNodes.length ? null : node.textContent;\n}\n\n/**\n * Check if two nodes are different\n * @param  {Node}  node1 The first node\n * @param  {Node}  node2 The second node\n * @return {Boolean}     If true, they're not the same node\n */\nfunction isDifferentNode (node1, node2) {\n\treturn (\n\t\t(typeof node1.nodeType === 'number' && node1.nodeType !== node2.nodeType) ||\n\t\t(typeof node1.tagName === 'string' && node1.tagName !== node2.tagName) ||\n\t\t(typeof node1.id === 'string' && node1.id !== node2.id) ||\n\t\t(typeof node1.src === 'string' && node1.src !== node2.src)\n\t);\n}\n\n/**\n * Check if the desired node is further ahead in the DOM existingNodes\n * @param  {Node}     node           The node to look for\n * @param  {NodeList} existingNodes  The DOM existingNodes\n * @param  {Integer}  index          The indexing index\n * @return {Integer}                 How many nodes ahead the target node is\n */\nfunction aheadInTree (node, existingNodes, index) {\n\treturn Array.from(existingNodes).slice(index + 1).find(function (branch) {\n\t\treturn !isDifferentNode(node, branch);\n\t});\n}\n\n/**\n * If there are extra elements in DOM, remove them\n * @param  {Array} existingNodes      The existing DOM\n * @param  {Array} templateNodes The template\n */\nfunction trimExtraNodes (existingNodes, templateNodes) {\n\tlet extra = existingNodes.length - templateNodes.length;\n\tif (extra < 1)  return;\n\tfor (; extra > 0; extra--) {\n\t\texistingNodes[existingNodes.length - 1].remove();\n\t}\n}\n\n/**\n * Remove scripts from HTML\n * @param  {Node}    elem The element to remove scripts from\n */\nfunction removeScripts (elem) {\n\tlet scripts = elem.querySelectorAll('script');\n\tfor (let script of scripts) {\n\t\tscript.remove();\n\t}\n}\n\n/**\n * Diff the existing DOM node versus the template\n * @param  {Array}   template The template HTML\n * @param  {Node}    existing The current DOM HTML\n * @param  {Boolean} events   If true, inline events allowed\n */\nfunction diff (template, existing, events) {\n\n\t// Get the nodes in the template and existing UI\n\tlet templateNodes = template.childNodes;\n\tlet existingNodes = existing.childNodes;\n\n\t// Don't inject scripts\n\tif (removeScripts(template)) return;\n\n\t// Loop through each node in the template and compare it to the matching element in the UI\n\ttemplateNodes.forEach(function (node, index) {\n\n\t\t// If element doesn't exist, create it\n\t\tif (!existingNodes[index]) {\n\t\t\tlet clone = node.cloneNode(true);\n\t\t\taddDefaultAtts(clone, events);\n\t\t\texisting.append(clone);\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is, but it's not the same node type, insert the new node before the existing one\n\t\tif (isDifferentNode(node, existingNodes[index])) {\n\n\t\t\t// Check if node exists further in the tree\n\t\t\tlet ahead = aheadInTree(node, existingNodes, index);\n\n\t\t\t// If not, insert the node before the current one\n\t\t\tif (!ahead) {\n\t\t\t\tlet clone = node.cloneNode(true);\n\t\t\t\taddDefaultAtts(clone, events);\n\t\t\t\texistingNodes[index].before(clone);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, move it to the current spot\n\t\t\texistingNodes[index].before(ahead);\n\n\t\t}\n\n\t\t// If attributes are different, update them\n\t\tdiffAttributes(node, existingNodes[index], events);\n\n\t\t// Stop diffing if a native web component\n\t\tif (node.nodeName.includes('-')) return;\n\n\t\t// If content is different, update it\n\t\tlet templateContent = getNodeContent(node);\n\t\tif (templateContent && templateContent !== getNodeContent(existingNodes[index])) {\n\t\t\texistingNodes[index].textContent = templateContent;\n\t\t}\n\n\t\t// If there shouldn't be child nodes but there are, remove them\n\t\tif (!node.childNodes.length && existingNodes[index].childNodes.length) {\n\t\t\texistingNodes[index].innerHTML = '';\n\t\t\treturn;\n\t\t}\n\n\t\t// If DOM is empty and shouldn't be, build it up\n\t\t// This uses a document fragment to minimize reflows\n\t\tif (!existingNodes[index].childNodes.length && node.childNodes.length) {\n\t\t\tlet fragment = document.createDocumentFragment();\n\t\t\tdiff(node, fragment, events);\n\t\t\texistingNodes[index].appendChild(fragment);\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are nodes within it, recursively diff those\n\t\tif (node.childNodes.length) {\n\t\t\tdiff(node, existingNodes[index], events);\n\t\t}\n\n\t});\n\n\t// If extra elements in DOM, remove them\n\ttrimExtraNodes(existingNodes, templateNodes);\n\n}\n\n/**\n * Render a template into the UI\n * @param  {Node|String} elem     The element or selector to render the template into\n * @param  {String}      template The template to render\n * @param  {Boolean}     events   If true, inline events allowed\n */\nfunction render (elem, template, events) {\n\tlet node = getElem(elem);\n\tlet html = stringToHTML(template);\n\tdiff(html, node, events);\n\temit('render', null, node);\n}\n\nexport default render;", "import render from './render.js';\nimport {emit, getElem} from './utilities.js';\n\n\n/**\n * Create the event handler function\n * @param {Class} instance The instance\n */\nfunction createHandler (instance) {\n\treturn function handler (event) {\n\t\tinstance.render();\n\t};\n}\n\n/**\n * Component Class\n */\nclass Component {\n\n\t/**\n\t * The constructor object\n\t * @param  {Node|String} elem     The element or selector to render the template into\n\t * @param  {Function}    template The template function to run when the data updates\n\t * @param  {Object}      options  Additional options\n\t */\n\tconstructor (elem, template, options) {\n\n\t\t// Create instance properties\n\t\tthis.elem = elem;\n\t\tthis.template = template;\n\t\tthis.stores = options.stores ? options.stores.map((store) => `reef:store-${store}`) : ['reef:store'];\n\t\tthis.events = options.events;\n\t\tthis.handler = createHandler(this);\n\t\tthis.debounce = null;\n\n\t\t// Init\n\t\tthis.start();\n\n\t}\n\n\t/**\n\t * Start reactive data rendering\n\t */\n\tstart () {\n\t\tfor (let store of this.stores) {\n\t\t\tdocument.addEventListener(store, this.handler);\n\t\t}\n\t\tthis.render();\n\t\temit('start', null, getElem(this.elem));\n\t}\n\n\t/**\n\t * Stop reactive data rendering\n\t */\n\tstop () {\n\t\tfor (let store of this.stores) {\n\t\t\tdocument.removeEventListener(store, this.handler);\n\t\t}\n\t\temit('stop', null, getElem(this.elem));\n\t}\n\n\t/**\n\t * Render the UI\n\t */\n\trender () {\n\n\t\t// Cache instance\n\t\tlet self = this;\n\n\t\t// If there's a pending render, cancel it\n\t\tif (self.debounce) {\n\t\t\twindow.cancelAnimationFrame(self.debounce);\n\t\t}\n\n\t\t// Setup the new render to run at the next animation frame\n\t\tself.debounce = window.requestAnimationFrame(function () {\n\t\t\trender(self.elem, self.template(), self.events);\n\t\t});\n\n\t}\n\n}\n\n/**\n * Create a new listener\n * @param  {Node|String} elem     The element or selector to render the template into\n * @param  {Function}    template The template function to run when the data updates\n * @param  {Object}      options  Additional options\n */\nfunction component (elem, template, options = {}) {\n\treturn new Component(elem, template, options);\n}\n\n\nexport default component;"],
  "mappings": "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",
  "names": ["emit", "type", "detail", "elem", "document", "event", "CustomEvent", "bubbles", "cancelable", "dispatchEvent", "getElem", "querySelector", "getType", "obj", "Object", "prototype", "toString", "call", "slice", "toLowerCase", "store", "data", "name", "includes", "value", "Proxy", "handler", "get", "prop", "_isProxy", "set", "deleteProperty", "Setter", "[object Object]", "setters", "defineProperties", "this", "copy", "clone", "key", "hasOwnProperty", "cloneObj", "map", "item", "fn", "args", "setter", "formFields", "formAtts", "formAttsNoVal", "isFalsy", "str", "skipAttribute", "events", "val", "replace", "startsWith", "addAttribute", "att", "setAttribute", "removeAttribute", "addDefaultAtts", "nodeType", "attributes", "attName", "childNodes", "node", "getNodeContent", "length", "textContent", "isDifferentNode", "node1", "node2", "tagName", "id", "src", "diff", "template", "existing", "templateNodes", "existingNodes", "scripts", "querySelectorAll", "script", "remove", "forEach", "index", "cloneNode", "append", "ahead", "Array", "from", "find", "branch", "before", "templateAtts", "existingAtts", "nodeName", "templateContent", "fragment", "createDocumentFragment", "appendChild", "innerHTML", "extra", "render", "doc", "DOMParser", "parseFromString", "head", "reverse", "body", "insertBefore", "firstChild", "createElement", "Component", "options", "instance", "stores", "debounce", "start", "addEventListener", "removeEventListener", "self", "window", "cancelAnimationFrame", "requestAnimationFrame", "component"]
}
